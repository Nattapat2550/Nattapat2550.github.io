<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ดอกกุหลาบ 128bit สวย พร้อมหัวใจ 4 ดวง ขยับ แตกได้</title>
<style>
  body {
    margin:0; padding:0;
    background: #111;
    display: flex; justify-content: center; align-items: center;
    height: 100vh;
    user-select: none;
    overflow: hidden;
  }
  canvas {
    image-rendering: pixelated;
    border: 5px solid #ff1e7f;
    border-radius: 20px;
    background: #222;
    box-shadow: 0 0 20px #ff1e7faa;
  }
</style>
</head>
<body>
<canvas id="canvas" width="512" height="512"></canvas>

<script>
const PIXEL_SIZE = 4;
const WIDTH = 128;
const HEIGHT = 128;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

canvas.style.width = canvas.width + 'px';
canvas.style.height = canvas.height + 'px';

// ฟังก์ชันไล่สีดอกกุหลาบแบบมี layering และไล่โทนสีละเอียดขึ้น
function getRoseColor(x, y) {
  const cx = WIDTH/2;
  const cy = HEIGHT/2;
  const dx = x - cx;
  const dy = y - cy;
  const dist = Math.sqrt(dx*dx + dy*dy);

  if(dist > 55) return null;

  // โทนสีหลายเลเยอร์ ไล่สีลึกลงไป
  if(dist < 10) return {r: 190, g: 30, b: 45, a:255};         // แดงเข้มมาก
  if(dist < 20) return {r: 230, g: 40, b: 70, a:255};         // แดงสด
  if(dist < 30) return {r: 255, g: 80, b: 130, a:255};        // ชมพูสดใส
  if(dist < 40) return {r: 235, g: 120, b: 150, a:255};       // ชมพูอมม่วง
  if(dist < 50) return {r: 215, g: 70, b: 120, a:255};        // ชมพูเข้ม
  return null;
}

// สร้าง array pixel ของดอกกุหลาบ
let rosePixels = [];
for(let y=0; y<HEIGHT; y++) {
  for(let x=0; x<WIDTH; x++) {
    let c = getRoseColor(x,y);
    if(c) rosePixels.push({x,y,color:c});
  }
}

// เก็บ pixel ที่วาดแล้ว (วาดค้างไว้ไม่หาย)
let drawnPixels = new Set();

// วาดหัวใจ pixel art ขนาด 6x6 pixel
const heartPattern = [
  [0,1,1,0,0,0],
  [1,1,1,1,0,0],
  [1,1,1,1,1,0],
  [0,1,1,1,1,0],
  [0,0,1,1,0,0],
  [0,0,0,0,0,0]
];

class Heart {
  constructor(x,y) {
    this.x = x;
    this.y = y;
    this.size = 6;
    this.pixelSize = PIXEL_SIZE;
    this.offsetX = 0;
    this.offsetY = 0;
    this.vx = (Math.random()*1-0.5)*0.5;
    this.vy = (Math.random()*1-0.5)*0.5;
    this.broken = false;
    this.particles = [];
  }

  draw(ctx) {
    if(this.broken) {
      this.particles.forEach(p=>{
        p.update();
        p.draw(ctx);
      });
      this.particles = this.particles.filter(p => p.alpha > 0);
      return;
    }

    ctx.fillStyle = '#ff6699';
    for(let py=0; py<this.size; py++) {
      for(let px=0; px<this.size; px++) {
        if(heartPattern[py][px]) {
          const drawX = (this.x + px + this.offsetX) * this.pixelSize;
          const drawY = (this.y + py + this.offsetY) * this.pixelSize;
          ctx.fillRect(drawX, drawY, this.pixelSize, this.pixelSize);
        }
      }
    }
  }

  update() {
    if(this.broken) {
      this.particles.forEach(p=>p.update());
      this.particles = this.particles.filter(p => p.alpha > 0);
      return;
    }

    this.offsetX += this.vx;
    this.offsetY += this.vy;

    if(this.offsetX > 1 || this.offsetX < -1) this.vx *= -1;
    if(this.offsetY > 1 || this.offsetY < -1) this.vy *= -1;
  }

  breakApart() {
    if(this.broken) return;
    this.broken = true;
    for(let py=0; py<this.size; py++) {
      for(let px=0; px<this.size; px++) {
        if(heartPattern[py][px]) {
          this.particles.push(new Particle(
            (this.x + px) * this.pixelSize,
            (this.y + py) * this.pixelSize,
            this.pixelSize
          ));
        }
      }
    }
  }

  isPointInside(px, py) {
    const localX = Math.floor((px/this.pixelSize) - this.x - this.offsetX);
    const localY = Math.floor((py/this.pixelSize) - this.y - this.offsetY);
    if(localX < 0 || localX >= this.size) return false;
    if(localY < 0 || localY >= this.size) return false;
    return heartPattern[localY][localX] === 1;
  }
}

class Particle {
  constructor(x,y,size) {
    this.x = x + Math.random()*size;
    this.y = y + Math.random()*size;
    this.size = size;
    this.vx = (Math.random()-0.5)*3;
    this.vy = (Math.random()-0.5)*3;
    this.alpha = 1;
    this.gravity = 0.05;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += this.gravity;
    this.alpha -= 0.03;
    if(this.alpha < 0) this.alpha = 0;
  }

  draw(ctx) {
    ctx.fillStyle = `rgba(255,102,153,${this.alpha.toFixed(2)})`;
    ctx.fillRect(this.x, this.y, this.size, this.size);
  }
}

// สร้างหัวใจ 4 ดวงรอบดอกกุหลาบ
const hearts = [];
const centerX = WIDTH / 2;
const centerY = HEIGHT / 2;
const heartOffsets = [
  [-22, -22],
  [22, -22],
  [-22, 22],
  [22, 22]
];
heartOffsets.forEach(offset => {
  hearts.push(new Heart(centerX + offset[0], centerY + offset[1]));
});

let roseIndex = 0;

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // วาดหัวใจ
  hearts.forEach(h => {
    h.update();
    h.draw(ctx);
  });

  // วาดดอกกุหลาบทีละบิตและเก็บ pixel ที่วาดแล้ว
  let pixelsDrawnThisFrame = 0;
  while(pixelsDrawnThisFrame < 10 && roseIndex < rosePixels.length) {
    const p = rosePixels[roseIndex];
    const key = `${p.x},${p.y}`;
    if(!drawnPixels.has(key)) {
      ctx.fillStyle = `rgba(${p.color.r},${p.color.g},${p.color.b},${p.color.a/255})`;
      ctx.fillRect(p.x * PIXEL_SIZE, p.y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
      drawnPixels.add(key);
      pixelsDrawnThisFrame++;
    }
    roseIndex++;
  }

  // วาด pixel ที่วาดไปแล้วทั้งหมดค้างไว้ (ไม่ให้หาย)
  drawnPixels.forEach(key => {
    const [x, y] = key.split(',').map(Number);
    const p = rosePixels.find(px => px.x === x && px.y === y);
    if(p) {
      ctx.fillStyle = `rgba(${p.color.r},${p.color.g},${p.color.b},${p.color.a/255})`;
      ctx.fillRect(p.x * PIXEL_SIZE, p.y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
    }
  });

  requestAnimationFrame(draw);
}
draw();

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const clickX = (e.clientX - rect.left);
  const clickY = (e.clientY - rect.top);

  for(let i=hearts.length-1; i>=0; i--) {
    const h = hearts[i];
    if(h.isPointInside(clickX, clickY)) {
      h.breakApart();
      break;
    }
  }
});
</script>
</body>
</html>
