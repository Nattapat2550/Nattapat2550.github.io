<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ดอกกุหลาบ 128bit + หัวใจ 4 ดวงขยับ + แตกเมื่อกด</title>
<style>
  body {
    margin:0; padding:0;
    background: #111;
    display: flex; justify-content: center; align-items: center;
    height: 100vh;
    user-select: none;
    overflow: hidden;
  }
  canvas {
    image-rendering: pixelated;
    border: 4px solid #ff007f;
    border-radius: 15px;
    background: #222;
  }
</style>
</head>
<body>
<canvas id="canvas" width="512" height="512"></canvas>

<script>
// ขนาด canvas และ pixel art
const PIXEL_SIZE = 4;  // ขยาย 4 เท่า
const WIDTH = 128;
const HEIGHT = 128;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

canvas.style.width = canvas.width + 'px';
canvas.style.height = canvas.height + 'px';

ctx.imageSmoothingEnabled = false;

// ดอกกุหลาบ pixel art (128x128) สร้างเป็นวงกลมไล่สีแบบง่ายๆ (แทน pixel art จริง)
function getRoseColor(x, y) {
  const cx = WIDTH / 2;
  const cy = HEIGHT / 2;
  const dx = x - cx;
  const dy = y - cy;
  const dist = Math.sqrt(dx*dx + dy*dy);

  if(dist > 50) return null; // นอกวงกลมดอกกุหลาบ

  if(dist < 15) return {r: 178, g: 34, b: 34, a:255}; // แดงเข้ม
  else if(dist < 30) return {r: 255, g: 105, b: 180, a:255}; // ชมพู
  else if(dist < 45) return {r: 216, g: 112, b: 147, a:255}; // ชมพูเข้ม
  else return null;
}

let rosePixels = [];
for(let y=0; y<HEIGHT; y++) {
  for(let x=0; x<WIDTH; x++) {
    const c = getRoseColor(x,y);
    if(c) rosePixels.push({x,y,color:c});
  }
}

// วาดดอกกุหลาบครบแล้วเก็บภาพไว้ไม่หาย
let roseIndex = 0;
let roseComplete = false;

// หัวใจ pixel art ขนาด 6x6 pixel (2x2 block จริงบน canvas เพราะ pixel ขยาย 4 เท่า)
const heartPattern = [
  [0,1,1,0,0,0],
  [1,1,1,1,0,0],
  [1,1,1,1,1,0],
  [0,1,1,1,1,0],
  [0,0,1,1,0,0],
  [0,0,0,0,0,0]
];

class Heart {
  constructor(x,y) {
    this.x = x;
    this.y = y;
    this.size = 6; 
    this.pixelSize = PIXEL_SIZE;
    this.offsetX = 0; 
    this.offsetY = 0;
    this.vx = (Math.random()*1-0.5)*0.5;
    this.vy = (Math.random()*1-0.5)*0.5;
    this.broken = false; 
    this.particles = [];
  }

  draw(ctx) {
    if(this.broken) {
      this.particles.forEach(p=>{
        p.update();
        p.draw(ctx);
      });
      this.particles = this.particles.filter(p => p.alpha > 0);
      return;
    }

    ctx.fillStyle = '#ff6699';
    for(let py=0; py<this.size; py++) {
      for(let px=0; px<this.size; px++) {
        if(heartPattern[py][px]) {
          const drawX = (this.x + px + this.offsetX) * this.pixelSize;
          const drawY = (this.y + py + this.offsetY) * this.pixelSize;
          ctx.fillRect(drawX, drawY, this.pixelSize, this.pixelSize);
        }
      }
    }
  }

  update() {
    if(this.broken) {
      this.particles.forEach(p=>p.update());
      this.particles = this.particles.filter(p => p.alpha > 0);
      return;
    }

    this.offsetX += this.vx;
    this.offsetY += this.vy;

    if(this.offsetX > 1 || this.offsetX < -1) this.vx *= -1;
    if(this.offsetY > 1 || this.offsetY < -1) this.vy *= -1;
  }

  breakApart() {
    if(this.broken) return;
    this.broken = true;
    for(let py=0; py<this.size; py++) {
      for(let px=0; px<this.size; px++) {
        if(heartPattern[py][px]) {
          this.particles.push(new Particle(
            (this.x + px) * this.pixelSize,
            (this.y + py) * this.pixelSize,
            this.pixelSize
          ));
        }
      }
    }
  }

  isPointInside(px, py) {
    const localX = Math.floor((px/this.pixelSize) - this.x - this.offsetX);
    const localY = Math.floor((py/this.pixelSize) - this.y - this.offsetY);
    if(localX < 0 || localX >= this.size) return false;
    if(localY < 0 || localY >= this.size) return false;
    return heartPattern[localY][localX] === 1;
  }
}

class Particle {
  constructor(x,y,size) {
    this.x = x + Math.random()*size;
    this.y = y + Math.random()*size;
    this.size = size;
    this.vx = (Math.random()-0.5)*3;
    this.vy = (Math.random()-0.5)*3;
    this.alpha = 1;
    this.gravity = 0.05;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += this.gravity;
    this.alpha -= 0.03;
    if(this.alpha < 0) this.alpha = 0;
  }

  draw(ctx) {
    ctx.fillStyle = `rgba(255,102,153,${this.alpha.toFixed(2)})`;
    ctx.fillRect(this.x, this.y, this.size, this.size);
  }
}

// สร้างหัวใจแค่ 4 ดวงรอบดอกกุหลาบ
const hearts = [];
const centerX = WIDTH / 2;
const centerY = HEIGHT / 2;
const heartOffsets = [
  [-20, -20],
  [20, -20],
  [-20, 20],
  [20, 20]
];
heartOffsets.forEach(offset => {
  hearts.push(new Heart(centerX + offset[0], centerY + offset[1]));
});

function draw() {
  ctx.clearRect(0,0,canvas.width, canvas.height);

  // วาดหัวใจขยับ
  hearts.forEach(h => {
    h.update();
    h.draw(ctx);
  });

  // วาดดอกกุหลาบทีละบิต
  if(!roseComplete) {
    for(let i=0; i<5 && roseIndex < rosePixels.length; i++) {
      const p = rosePixels[roseIndex];
      ctx.fillStyle = `rgba(${p.color.r},${p.color.g},${p.color.b},${p.color.a/255})`;
      ctx.fillRect(p.x * PIXEL_SIZE, p.y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
      roseIndex++;
    }
    if(roseIndex >= rosePixels.length) {
      roseComplete = true;
    }
  } else {
    // วาดดอกกุหลาบเต็มที่เก็บไว้ไม่หาย
    for(let i=0; i < rosePixels.length; i++) {
      const p = rosePixels[i];
      ctx.fillStyle = `rgba(${p.color.r},${p.color.g},${p.color.b},${p.color.a/255})`;
      ctx.fillRect(p.x * PIXEL_SIZE, p.y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
    }
  }

  requestAnimationFrame(draw);
}
draw();

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const clickX = (e.clientX - rect.left);
  const clickY = (e.clientY - rect.top);

  for(let i=hearts.length-1; i>=0; i--) {
    const h = hearts[i];
    if(h.isPointInside(clickX, clickY)) {
      h.breakApart();
      break;
    }
  }
});
</script>
</body>
</html>
